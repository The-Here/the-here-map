<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Here â€” Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

  <style>
    body { margin: 0; padding: 0; background: #ffffff; }
    #map { position: absolute; inset: 0; }
  </style>
</head>
<body>

<div id="map"></div>

<script>
  mapboxgl.accessToken = 'pk.eyJ1Ijoibm9ydGhlZGRhIiwiYSI6ImNtYmVjczJ4cTFndnEycW42cnFwbjBjbzcifQ.XYvDSeoj0uD6K8WpK5v0mQ';

  /**
   * FIX: To show Chukotka and Alaska without clipping, we allow the 
   * longitude to go slightly past 180 degrees.
   * To prevent "flipping" at the poles, we stop at 85 degrees.
   */
  const bounds = [
    [-205, -85.05], // Southwest: Covers Antarctica and Eastern Russia
    [205, 85.05]    // Northeast: Covers the Arctic and Alaska
  ];

  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/light-v11',
    projection: 'mercator',
    center: [0, 20],
    zoom: 1,
    minZoom: 0.8,    // Set minZoom so the map fits the screen nicely
    maxZoom: 12,
    renderWorldCopies: false, // STOPS horizontal scrolling/looping
    maxBounds: bounds         // STOPS vertical flipping and edge-clipping
  });

  const POLYGON_MAX_CLICK_ZOOM = 3;

  map.on('load', async () => {
    try {
      const manifestRes = await fetch('manifest.json');
      const manifest = await manifestRes.json();
      const pointLayers = [];

      for (const dataset of manifest.datasets) {
        const sourceId = dataset.id;
        const isPoint = dataset.geometryType === 'point';
        const isPolygon = dataset.geometryType === 'polygon';

        const res = await fetch(dataset.file);
        const geojson = await res.json();

        // ----- SOURCES -----
        if (isPoint) {
          map.addSource(sourceId, {
            type: 'geojson',
            data: geojson,
            cluster: true,
            clusterMaxZoom: 9,
            clusterRadius: 50
          });
        } else {
          map.addSource(sourceId, {
            type: 'geojson',
            data: geojson
          });
        }

        // ----- LAYERS -----
        if (isPoint) {
          map.addLayer({
            id: `${sourceId}-clusters`,
            type: 'circle',
            source: sourceId,
            filter: ['has', 'point_count'],
            paint: {
              'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 10, '#f1f075', 30, '#f28cb1'],
              'circle-radius': ['step', ['get', 'point_count'], 15, 10, 20, 30, 25]
            }
          });

          map.addLayer({
            id: `${sourceId}-cluster-count`,
            type: 'symbol',
            source: sourceId,
            filter: ['has', 'point_count'],
            layout: {
              'text-field': ['get', 'point_count_abbreviated'],
              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
              'text-size': 12
            }
          });

          map.addLayer({
            id: `${sourceId}-unclustered-point`,
            type: 'circle',
            source: sourceId,
            filter: ['!', ['has', 'point_count']],
            paint: {
              'circle-radius': 8,
              'circle-color': '#000000',
              'circle-opacity': 0.9,
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 1
            }
          });

          pointLayers.push(`${sourceId}-unclustered-point`);

          // Interaction: Cluster Click
          map.on('click', `${sourceId}-clusters`, (e) => {
            const features = map.queryRenderedFeatures(e.point, { layers: [`${sourceId}-clusters`] });
            if (!features.length) return;
            const clusterId = features[0].properties.cluster_id;
            map.getSource(sourceId).getClusterExpansionZoom(clusterId, (err, zoom) => {
              if (err) return;
              map.easeTo({ center: features[0].geometry.coordinates, zoom: zoom });
            });
          });

          // Interaction: Point Click
          map.on('click', `${sourceId}-unclustered-point`, (e) => {
            const f = e.features && e.features[0];
            if (!f) return;
            const p = f.properties || {};
            const html = `<strong>${p.label || p.id || 'Event'}</strong><br>${p.date || ''}`;
            new mapboxgl.Popup().setLngLat(e.lngLat).setHTML(html).addTo(map);
          });
        } else if (isPolygon) {
          const fillId = `${sourceId}-fill`;
          map.addLayer({
            id: fillId,
            type: 'fill',
            source: sourceId,
            paint: {
              'fill-color': ['interpolate', ['linear'], ['get', 'intensity'], 1, '#fee2e2', 3, '#f97373', 5, '#7f1d1d'],
              'fill-opacity': ['interpolate', ['linear'], ['get', 'intensity'], 1, 0.15, 5, 0.6]
            }
          });

          map.addLayer({
            id: `${sourceId}-outline`,
            type: 'line',
            source: sourceId,
            paint: { 'line-color': '#111827', 'line-width': 0.5 }
          });

          map.on('click', fillId, (e) => {
            if (map.getZoom() > POLYGON_MAX_CLICK_ZOOM) return;
            const nearbyPoints = map.queryRenderedFeatures(e.point, { layers: pointLayers });
            if (nearbyPoints.length > 0) return;

            const f = e.features && e.features[0];
            if (!f) return;
            const p = f.properties || {};
            const html = `<strong>${p.label || 'Area'}</strong><br>${p.intensity ? 'Intensity: '+p.intensity : ''}`;
            new mapboxgl.Popup().setLngLat(e.lngLat).setHTML(html).addTo(map);
          });
        }
      }
    } catch (err) {
      console.error("Data error:", err);
    }
  });
</script>

</body>
</html>
